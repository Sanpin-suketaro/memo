<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>è¶…ãƒ¡ãƒ¢å¸³ï¼ˆVanilla JSï¼‰</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* ã¡ã‚‡ã„è¶³ã— */
    .modal-enter { opacity: 0; transform: scale(.98); }
    .modal-enter-active { opacity: 1; transform: scale(1); transition: all 120ms ease; }
    .modal-leave { opacity: 1; }
    .modal-leave-active { opacity: 0; transition: opacity 120ms ease; }
    mark { padding: 0 .2em; border-radius: .25rem; }
  </style>
</head>
<body class="bg-slate-50">
  <div id="app" class="w-full h-[92vh] grid grid-cols-[300px_1fr]"></div>

  <!-- ç·¨é›†ãƒ¢ãƒ¼ãƒ€ãƒ« -->
  <div id="editModal" class="fixed inset-0 hidden items-center justify-center p-4 z-50 bg-black/30">
    <div class="w-full max-w-2xl bg-white rounded-2xl p-4 shadow-xl border">
      <div class="text-lg font-semibold mb-2">ãƒ¡ãƒ¢ã‚’ç·¨é›†</div>
      <textarea id="editTextarea" class="w-full h-48 border rounded-xl p-3"></textarea>
      <div class="mt-3 flex items-center justify-end gap-2">
        <button id="btnCancelEdit" class="px-3 py-2 text-sm">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
        <button id="btnSaveEdit" class="px-4 py-2 rounded-xl bg-black text-white text-sm">ä¿å­˜</button>
      </div>
    </div>
  </div>

  <script>
    // ============ å°ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ ============
    const LS_KEY = "super-memo-pad-v1";
    const nowIso = () => new Date().toISOString();
    const uid = () => `${Date.now()}_${Math.random().toString(36).slice(2,7)}`;

    const escapeHtml = (s) => s
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll('"', "&quot;")
      .replaceAll("'", "&#39;");

    const mdBold = (s) => s.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");

    function formatMDAndHighlight(raw, tokens = []) {
      let html = mdBold(escapeHtml(raw));
      if (tokens.length) {
        const sorted = [...tokens]
          .filter(Boolean)
          .map(t => t.trim())
          .filter(Boolean)
          .sort((a,b) => b.length - a.length);
        for (const t of sorted) {
          const re = new RegExp(`(${t.replace(/[.*+?^${}()|[\\]\\\\]/g, "\\$&")})`, "gi");
          html = html.replace(re, "<mark>$1</mark>");
        }
      }
      return html.replaceAll("\n", "<br>");
    }

    const ymd = (d) => {
      const dt = typeof d === 'string' ? new Date(d) : d;
      const y = dt.getFullYear();
      const m = `${dt.getMonth()+1}`.padStart(2,'0');
      const da = `${dt.getDate()}`.padStart(2,'0');
      return `${y}-${m}-${da}`;
    };

    const mdDisp = (d) => {
      const dt = typeof d === 'string' ? new Date(d) : d;
      return `${dt.getMonth()+1}/${dt.getDate()}`;
    };

    const DEFAULT_THESAURUS = [
      { base: "é‡è¦", words: ["å¤§äº‹","å„ªå…ˆ","è¦ç‚¹","è¦æ—¨"] },
      { base: "ãƒ¡ãƒ¢", words: ["ãƒãƒ¼ãƒˆ","è¨˜éŒ²","å‚™å¿˜","ãƒ¡ãƒ¢æ›¸ã"] },
      { base: "è²·ã†", words: ["è³¼å…¥","è²·ä»˜","å–å¾—"] },
      { base: "å£²ã‚‹", words: ["è²©å£²","å£²å´"] },
      { base: "ç¢ºèª", words: ["ãƒã‚§ãƒƒã‚¯","æ¤œè¨¼","è¦‹ç›´ã—"] },
      { base: "ãƒã‚°", words: ["ä¸å…·åˆ","éšœå®³","ä¸èª¿"] },
    ];

    const initialData = {
      userName: "ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«å",
      lists: [ { id: "inbox", name: "ã‚¤ãƒ³ãƒœãƒƒã‚¯ã‚¹", color: "#64748b" } ],
      memos: [], // {id, text, createdAt, updatedAt, pinned, listId}
      thesaurus: DEFAULT_THESAURUS,
    };

    // ============ çŠ¶æ…‹ ============
    let data;
    try {
      const saved = localStorage.getItem(LS_KEY);
      data = saved ? JSON.parse(saved) : initialData;
    } catch (e) { data = initialData; }

    // UI çŠ¶æ…‹
    let draft = "";
    let query = "";
    let useThesaurus = true;
    let filterListId = "all";
    let pinnedOnly = false;
    let dateFrom = "";
    let dateTo = "";

    let editingId = null; // ç¾åœ¨ç·¨é›†ä¸­ã®ãƒ¡ãƒ¢ID

    // ä¿å­˜
    function persist() {
      localStorage.setItem(LS_KEY, JSON.stringify(data));
    }

    // ============ ãƒ¡ãƒ¢æ“ä½œ ============
    function addMemo() {
      const text = draft.trim();
      if (!text) return;
      const m = {
        id: uid(),
        text,
        createdAt: nowIso(),
        updatedAt: nowIso(),
        pinned: false,
        listId: filterListId === 'all' ? 'inbox' : filterListId,
      };
      data.memos.push(m);
      draft = "";
      persist();
      render();
      // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«&ãƒ•ã‚©ãƒ¼ã‚«ã‚¹
      const scroller = document.getElementById('scroller');
      scroller?.scrollTo({ top: scroller.scrollHeight });
      document.getElementById('draftArea')?.focus();
    }

    function removeMemo(mid) {
      data.memos = data.memos.filter(m => m.id !== mid);
      persist(); render();
    }

    function togglePin(mid) {
      data.memos = data.memos.map(m => m.id === mid ? { ...m, pinned: !m.pinned } : m);
      persist(); render();
    }

    function updateMemo(mid, patch) {
      data.memos = data.memos.map(m => m.id === mid ? { ...m, ...patch, updatedAt: nowIso() } : m);
      persist(); render();
    }

    // ============ ãƒªã‚¹ãƒˆæ“ä½œ ============
    function addList(name, color) {
      const nm = (name||'').trim(); if (!nm) return;
      data.lists.push({ id: uid(), name: nm, color });
      persist(); render();
    }

    function removeList(lid) {
      if (lid === 'inbox') return;
      data.lists = data.lists.filter(l => l.id !== lid);
      data.memos = data.memos.map(m => m.listId === lid ? { ...m, listId: 'inbox' } : m);
      if (filterListId === lid) filterListId = 'all';
      persist(); render();
    }

    // ============ æ¤œç´¢ãƒ•ã‚£ãƒ«ã‚¿ ============
    function getQueryTokens() {
      if (!query.trim()) return [];
      const tokens = [query.trim()];
      if (useThesaurus) {
        const entry = data.thesaurus.find(t => t.base === query.trim() || t.words.includes(query.trim()));
        if (entry) tokens.push(...entry.words, entry.base);
      }
      return Array.from(new Set(tokens));
    }

    function computeFiltered() {
      const from = dateFrom ? new Date(dateFrom) : null;
      const to = dateTo ? new Date(dateTo) : null;
      const qtokens = getQueryTokens();

      return data.memos
        .filter(m => (filterListId === 'all' ? true : m.listId === filterListId))
        .filter(m => (pinnedOnly ? m.pinned : true))
        .filter(m => {
          if (!from && !to) return true;
          const t = new Date(m.createdAt);
          if (from && t < from) return false;
          if (to) {
            const end = new Date(to);
            end.setDate(end.getDate() + 1);
            if (t >= end) return false;
          }
          return true;
        })
        .filter(m => {
          if (!qtokens.length) return true;
          const body = m.text;
          return qtokens.some(tk => body.toLowerCase().includes(tk.toLowerCase()));
        })
        .sort((a,b) => new Date(a.createdAt) - new Date(b.createdAt));
    }

    function groupByDate(items) {
      const map = new Map();
      for (const m of items) {
        const key = ymd(m.createdAt);
        if (!map.has(key)) map.set(key, []);
        map.get(key).push(m);
      }
      return Array.from(map.entries()).sort((a,b) => new Date(a[0]) - new Date(b[0]));
    }

    function findList(id) { return data.lists.find(l => l.id === id) || data.lists[0]; }

    // ============ ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚° ============
    function render() {
      // å·¦ã‚µã‚¤ãƒ‰
      const listButtons = `
        <button data-action="filter-all" class="flex items-center justify-between px-3 py-2 rounded-lg text-sm border ${filterListId==='all'?'bg-slate-100':'bg-white'}">
          <span class="flex items-center gap-2"><span class="w-2 h-2 rounded-full bg-slate-400"></span>ã™ã¹ã¦</span>
          <span class="text-slate-500">${data.memos.length}</span>
        </button>
        ${data.lists.map(l => `
          <div class="flex items-center gap-2" data-list-row="${l.id}">
            <button data-action="filter-list" data-id="${l.id}" class="flex-1 flex items-center justify-between px-3 py-2 rounded-lg text-sm border ${filterListId===l.id?'bg-slate-100':'bg-white'}">
              <span class="flex items-center gap-2">
                <span class="w-2 h-2 rounded-full" style="background:${l.color}"></span>${l.name}
              </span>
              <span class="text-slate-500">${data.memos.filter(m=>m.listId===l.id).length}</span>
            </button>
            ${l.id!=='inbox' ? `<button data-action="remove-list" data-id="${l.id}" class="px-2 py-2 text-slate-400 hover:text-red-500" title="ãƒªã‚¹ãƒˆå‰Šé™¤">âœ•</button>` : ''}
          </div>
        `).join('')}
      `;

      const left = `
        <aside class="h-full border-r bg-white p-4 flex flex-col gap-4">
          <div class="flex items-center gap-3">
            <img src="title.png" alt="è¶…ãƒ¡ãƒ¢å¸³" class="h-10 object-contain" />
          </div>
          <div class="bg-slate-100 rounded-2xl p-4 flex flex-col items-center gap-3">
            <div class="w-24 h-24 rounded-full bg-gradient-to-br from-slate-200 to-slate-300 flex items-center justify-center text-4xl">ğŸ‘¤</div>
            <input id="userName" class="text-center text-sm bg-white rounded-md px-2 py-1 w-full border" value="${escapeHtml(data.userName)}" />
            <div class="text-sm text-slate-600">ç·ãƒ¡ãƒ¢æ•°ï¼š${data.memos.length}</div>
            <button id="togglePinnedOnly" class="w-full rounded-xl px-3 py-2 text-sm border flex items-center justify-center gap-2 ${pinnedOnly? 'bg-yellow-50 border-yellow-400':'bg-white'}" title="ãƒ”ãƒ³ç•™ã‚ã ã‘è¡¨ç¤º">
              <span>ğŸ“Œ ãƒ”ãƒ³</span>
              ${pinnedOnly ? '<span class="text-yellow-600">ON</span>' : ''}
            </button>
          </div>
          <div class="flex-1 overflow-auto">
            <div class="text-xs font-medium text-slate-500 mb-2">ãƒªã‚¹ãƒˆ</div>
            <div class="flex flex-col gap-1">${listButtons}</div>
          </div>
          <div class="border-t pt-3">
            <div class="text-xs font-medium text-slate-500 mb-2">æ–°ã—ã„ãƒªã‚¹ãƒˆ</div>
            <div class="flex items-center gap-2">
              <input id="newListName" class="flex-1 border rounded-md px-2 py-1 text-sm" placeholder="ãƒªã‚¹ãƒˆå" />
              <input id="newListColor" type="color" class="w-10 h-8 border rounded" value="#22c55e" title="è‰²" />
              <button id="btnAddList" class="px-3 py-2 rounded-lg border text-sm">è¿½åŠ </button>
            </div>
          </div>
        </aside>
      `;

      // ãƒ¡ã‚¤ãƒ³ï¼ˆæ¤œç´¢è¡Œï¼‰
      const mainTop = `
        <div class="p-3 border-b bg-white flex items-center gap-3">
          <div class="flex items-center gap-2 flex-1 border rounded-xl px-3 py-2 bg-slate-50">
            <span>ğŸ”</span>
            <input id="q" value="${escapeHtml(query)}" placeholder="æ–‡å­—ã‚’å…¥åŠ›ã—ã¦æ¤œç´¢" class="flex-1 bg-transparent outline-none text-sm" />
            <label class="text-xs flex items-center gap-1 select-none">
              <input id="useThesaurus" type="checkbox" ${useThesaurus? 'checked': ''} /> é¡èª
            </label>
          </div>
          <div class="flex items-center gap-2 text-xs">
            <span>æ—¥ä»˜</span>
            <input id="dateFrom" type="date" class="border rounded px-2 py-1" value="${dateFrom}" />
            <span>ã€œ</span>
            <input id="dateTo" type="date" class="border rounded px-2 py-1" value="${dateTo}" />
            <button id="btnClear" class="ml-2 text-slate-600 underline">ã‚¯ãƒªã‚¢</button>
          </div>
        </div>`;

      // ãƒ¡ãƒ¢ä¸€è¦§
      const qtokens = getQueryTokens();
      const grouped = groupByDate(computeFiltered());
      const memoList = grouped.length === 0
        ? `<div class="text-center text-slate-400 py-10">ãƒ¡ãƒ¢ã¯ã‚ã‚Šã¾ã›ã‚“</div>`
        : grouped.map(([dateKey, memos]) => `
          <div class="flex flex-col gap-3">
            <div class="text-lg font-semibold text-slate-700">${mdDisp(dateKey)}</div>
            ${memos.map(m => `
              <div class="flex" data-memo-row="${m.id}">
                <div class="flex-1">
                  <div class="rounded-xl bg-white px-4 py-3 border shadow-sm">
                    <div class="max-w-none text-[15px] leading-7" data-body>${formatMDAndHighlight(m.text, qtokens)}</div>
                    <div class="mt-2 flex items-center justify-between text-xs text-slate-500">
                      <div class="flex items-center gap-2">
                        <span class="inline-flex items-center gap-2 text-xs px-2 py-1 rounded-full border" title="${findList(m.listId).name}" style="border-color:${findList(m.listId).color};color:${findList(m.listId).color}">
                          <span class="w-2 h-2 rounded-full" style="background:${findList(m.listId).color}"></span>${findList(m.listId).name}
                        </span>
                        <span>${new Date(m.createdAt).toLocaleString()}</span>
                      </div>
                      <div class="flex items-center gap-2">
                        <button data-action="pin" data-id="${m.id}" class="px-2 py-1 rounded-md border ${m.pinned? 'bg-yellow-50 border-yellow-400':'bg-white'}" title="ãƒ”ãƒ³ç•™ã‚">ğŸ“Œ</button>
                        <select data-action="move" data-id="${m.id}" class="border rounded-md px-2 py-1">
                          ${data.lists.map(l => `<option value="${l.id}" ${l.id===m.listId?'selected':''}>${l.name}</option>`).join('')}
                        </select>
                        <button data-action="edit" data-id="${m.id}" class="px-2 py-1 rounded-md border">ç·¨é›†</button>
                        <button data-action="remove" data-id="${m.id}" class="px-2 py-1 rounded-md border text-red-600">å‰Šé™¤</button>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            `).join('')}
          </div>
        `).join('');

      const mainMiddle = `<div id="scroller" class="overflow-auto p-4 flex flex-col gap-4 bg-slate-50">${memoList}<div></div></div>`;

      // å…¥åŠ›æ¬„
      const addTarget = filterListId === 'all' ? 'inbox' : filterListId;
      const mainBottom = `
        <div class="border-t bg-white p-3">
          <div class="rounded-2xl border bg-slate-50 p-2">
            <textarea id="draftArea" class="w-full h-24 resize-none bg-transparent outline-none px-3 py-2" placeholder="ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›\nç¯„å›²ã‚’é¸æŠã—ã¦ win[ctrl+B] / mac[cmd+B] ã§å¤ªå­—ã«ã™ã‚‹">${escapeHtml(draft)}</textarea>
            <div class="flex items-center justify-between px-2 pb-2">
              <div class="text-xs text-slate-500">**å¤ªå­—** / Ctrl(Cmd)+Enterã§è¿½åŠ </div>
              <div class="flex gap-2">
                <select id="addListSelect" class="border rounded-md px-2 py-1 text-sm" title="è¿½åŠ å…ˆãƒªã‚¹ãƒˆ">
                  ${data.lists.map(l => `<option value="${l.id}" ${l.id===addTarget?'selected':''}>${l.name}</option>`).join('')}
                </select>
                <button id="btnAddMemo" class="rounded-xl bg-black text-white px-4 py-2 text-sm" title="ãƒ¡ãƒ¢ã‚’è¿½åŠ ">è¿½åŠ </button>
              </div>
            </div>
          </div>
        </div>`;

      document.getElementById('app').innerHTML = `
        ${left}
        <main class="h-full grid grid-rows-[auto_1fr_auto]">${mainTop}${mainMiddle}${mainBottom}</main>
      `;

      // ===== ã‚¤ãƒ™ãƒ³ãƒˆæŸã­ =====
      // ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«å
      document.getElementById('userName').addEventListener('input', (e) => {
        data.userName = e.target.value;
        persist();
      });
      // ãƒ”ãƒ³ON/OFFè¡¨ç¤º
      document.getElementById('togglePinnedOnly').addEventListener('click', () => { pinnedOnly = !pinnedOnly; render(); });

      // ãƒªã‚¹ãƒˆé–¢é€£
      document.querySelectorAll('[data-action="filter-all"]').forEach(el => el.addEventListener('click', () => { filterListId='all'; render(); }));
      document.querySelectorAll('[data-action="filter-list"]').forEach(el => el.addEventListener('click', (e) => { filterListId = e.currentTarget.dataset.id; render(); }));
      document.querySelectorAll('[data-action="remove-list"]').forEach(el => el.addEventListener('click', (e) => { removeList(e.currentTarget.dataset.id); }));

      // æ–°è¦ãƒªã‚¹ãƒˆ
      document.getElementById('btnAddList').addEventListener('click', () => {
        const name = document.getElementById('newListName').value;
        const color = document.getElementById('newListColor').value;
        addList(name, color);
        document.getElementById('newListName').value = '';
      });

      // æ¤œç´¢
      document.getElementById('q').addEventListener('input', (e) => { query = e.target.value; render(); });
      document.getElementById('useThesaurus').addEventListener('change', (e) => { useThesaurus = e.target.checked; render(); });
      document.getElementById('dateFrom').addEventListener('change', (e) => { dateFrom = e.target.value; render(); });
      document.getElementById('dateTo').addEventListener('change', (e) => { dateTo = e.target.value; render(); });
      document.getElementById('btnClear').addEventListener('click', () => { query=''; dateFrom=''; dateTo=''; render(); });

      // ãƒ¡ãƒ¢ã®ãƒœã‚¿ãƒ³ï¼ˆå§”è­²ï¼‰
      document.getElementById('scroller').addEventListener('click', (e) => {
        const t = e.target.closest('[data-action]');
        if (!t) return;
        const id = t.dataset.id;
        const action = t.dataset.action;
        if (action === 'pin') togglePin(id);
        if (action === 'remove') removeMemo(id);
        if (action === 'edit') openEdit(id);
      });
      // ã‚»ãƒ¬ã‚¯ãƒˆç§»å‹•ï¼ˆå§”è­²ï¼‰
      document.getElementById('scroller').addEventListener('change', (e) => {
        const t = e.target;
        if (t.matches('[data-action="move"]')) {
          updateMemo(t.dataset.id, { listId: t.value });
        }
      });

      // è¿½åŠ å…ˆé¸æŠ
      document.getElementById('addListSelect').addEventListener('change', (e) => {
        filterListId = e.target.value; render();
      });

      // è¿½åŠ ãƒœã‚¿ãƒ³
      document.getElementById('btnAddMemo').addEventListener('click', addMemo);

      // å…¥åŠ›æ¬„ã‚­ãƒ¼æ“ä½œ
      const draftArea = document.getElementById('draftArea');
      draftArea.addEventListener('input', (e) => { draft = e.target.value; });
      draftArea.addEventListener('keydown', (e) => {
        const isB = (e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'b';
        if (isB) {
          e.preventDefault();
          const el = e.target;
          const start = el.selectionStart; const end = el.selectionEnd;
          const sel = draft.slice(start, end);
          const wrapped = `**${sel || 'å¼·èª¿'}**`;
          const next = draft.slice(0,start) + wrapped + draft.slice(end);
          draft = next; el.value = next;
          setTimeout(() => el.setSelectionRange(start+2, start+2 + (sel || 'å¼·èª¿').length), 0);
        } else if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
          e.preventDefault(); addMemo();
        }
      });
    }

    // ============ ç·¨é›†ãƒ¢ãƒ¼ãƒ€ãƒ« ============
    function openEdit(mid) {
      editingId = mid;
      const m = data.memos.find(x => x.id === mid);
      const modal = document.getElementById('editModal');
      const ta = document.getElementById('editTextarea');
      ta.value = m?.text || '';
      modal.classList.remove('hidden');
      modal.classList.add('flex');
      ta.focus();
    }

    function closeEdit() {
      const modal = document.getElementById('editModal');
      modal.classList.add('hidden');
      modal.classList.remove('flex');
      editingId = null;
    }

    document.getElementById('btnCancelEdit').addEventListener('click', closeEdit);
    document.getElementById('btnSaveEdit').addEventListener('click', () => {
      const val = document.getElementById('editTextarea').value;
      if (editingId) updateMemo(editingId, { text: val });
      closeEdit();
    });

    document.getElementById('editTextarea').addEventListener('keydown', (e) => {
      const isB = (e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'b';
      if (isB) {
        e.preventDefault();
        const el = e.target; const val = el.value;
        const start = el.selectionStart; const end = el.selectionEnd;
        const sel = val.slice(start, end);
        const wrapped = `**${sel || 'å¼·èª¿'}**`;
        const next = val.slice(0,start) + wrapped + val.slice(end);
        el.value = next; setTimeout(()=> el.setSelectionRange(start+2, start+2 + (sel || 'å¼·èª¿').length), 0);
      }
    });

    // åˆæœŸæç”»
    render();
  </script>
</body>
</html>